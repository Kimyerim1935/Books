# 표현식과 문 (50p)

> 값

<aside>
💡 값은 식(표현식)이 평가되어 생성된 결과를 말한다.
</aside>

변수는 **하나의 값**을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름이라고 했다. 

따라서 변수에 할당되는 것은 값이다.

자바스크립트는 ***값에 의한 전달(passed by value)*** 이 일어나는 5가지의 데이터타입(`Boolean`, `Null`, `Undefined`, `String`, `Number`)을 가지고 있다. 우리는 이러한 데이터 타입을 ***원시 타입(Primitive Types)*** 이라고 부른다.

또 자바스크립트는 ***참조에 의한 전달(passed by reference)*** 이 일어나는 3가지의 데이터 타입(`Array`, `Function`, `Object`)도 가지고 있다. 사실 이 3가지는 크게 보자면 전부 `객체(Objects)`로 볼 수 있다.

자바스크립트에서는 함수도 객체이다. 

> 리터럴

<aside>
💡 리터럴은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법을 말한다.
</aside>

프로그래밍이 기계어를 사용해 컴퓨터와 커뮤니케이션이라는 방법이라는 점을 고려할 때, 리터럴은 다음과 같이 커뮤니케이션의 방식을 특정하는 일종의 방법이다.

자바스크립트 엔진은 코드가 실행되는 시점인 런타임에 리터럴을 평가해 값을 생성한다.

즉, 리터럴은 값을 생성하기 위해 미리 약속한 표기법이라고 할 수 있다.

코드 상에서 **데이터를 표현하는 방식이다.**

리터럴 표기법이란, 변수를 선언함과 동시에 그 값을 지정해주는 표기법을 말한다.

```jsx
var no=3;
var str='';
var isTrue=true;
var obj={nation:'korea',age:15};
var func=function(){}
var arr=[];
var reg=/[a-z]/g;
```

[리터럴에 대해 더 알고 싶다면?](https://enarastudent.tistory.com/m/entry/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1%EA%B3%BC-%EB%A6%AC%ED%84%B0%EB%9F%B4-%ED%91%9C%EA%B8%B0%EB%B2%95)

> 표현식

<aside>
💡 표현식은 값으로 평가될 수 있는 문이다. 즉, 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다.
</aside>

값으로 평가될 수 있는 문은 모두 **표현식**이다.

따라서 리터럴도 표현식이다.

표현식은 값을 만들어낸다

표현식은 값 하나로 귀결되는 자바스크립트 코드 조각(snippet)이다. 표현식은 우리가 원하는만큼 길어질 수 있지만 언제나 동일한 값이 나오진 않는다.

표현식은 반드시 상태(State)를 바꿀 필요는 없다. 예를 들면,

```jsx
const assignedVariable = 2; // 이건 문장(Statement)입니다.assignedVariable은 상태입니다.
assignedVariable * 4 // 표현식(Expression)입니다.
assignedVariable * 10 // 표현식(Expression)입니다.
assignedVariable - 10 // 표현식(Expression)입니다.
console.log(assignedVariable) // 2
```

위의 짤막한 코드의 모든 표현식에도 불구하고 assignedVariable의 값은 여전히 2이다.

 함수 호출은 표현식이다. 하지만 함수는 값을 변화시키는 문장(Statement)을 포함할 수 있다. foo 내부의 foo() 함수는 undefined나 어떤 다른 값을 반환할 수 있는 표현식이다. 하지만 만일 foo가 다음과 같이 작성됐다면,

```jsx
const foo = foo () => { 
 assignedValue = 14 
}
```

그 땐, foo를 호출하는 것은 표현식일지라도, 함수를 호출하면 결국 상태(state)가 바뀌게 된다. 그래서 foo 함수를 더 나은 방법으로 재작성하려면 문장(Statement)는 다음과 같을 것이다.

```jsx
const foo = () => {
  return 14; // 가독성을 위한 명시적 반환 
}
assignedVariable = foo()
```

아니면 더 나은 방법으로

```jsx
const foo = foo (n) => { 
 return n // 가독성을 위한 명시적 반환 
}
assignedVariable = foo(14)
```

이 편이 더욱 가독성이 좋고, 어딘가에 끼워넣기 좋으며 표현식(Expression)과 문장(Statement) 사이에서 확연히 구분이 된다. 이것이 선언적이고 함수적인 자바스크립트의 기반이다.

[참고자료](https://velog.io/@jakeseo_me/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%9D%BC%EB%A9%B4-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%A0-33%EA%B0%80%EC%A7%80-%EA%B0%9C%EB%85%90-7-%ED%91%9C%ED%98%84%EC%8B%9D%EA%B3%BC-%EB%AC%B8Statement-%EB%B2%88%EC%97%AD-2xjuhvbal7)

> 문

<aside>
💡 문은 프로그램을 구성하는 기본 단위이자 최소 실행 단위다.
</aside>

<aside>
💡 토큰이란 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미한다.
</aside>

문은 선언문, 할당문, 조건문, 반복문 등으로 구분할 수 있다.

표현식은 문처럼 동작할 수 있지만, 문은 표현식처럼 동작할 수 없다.

문(statement)은 프로그램을 구성하는 기본 단위이자 최소 실행 단위다.

문은 값을 반환하지 않는다

문은 실행 시 사이드이펙트를 발생시킨다. 

문의 집합으로 이뤄진 것이 바로 프로그램이며, 문을 작성하고 순서에 맞게 나열하는 것이 프로그래밍이다.

문은 여러 토큰으로 구성된다. 

토큰(token)이란 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미한다.예를 들어 키워드, 식별자, 연산자, 리터럴, 세미콜론(;)이나 마침표(.)등의 특수 기호는 문법적 의미를 가지며, 더이상 나눌 수 없는 코드의 기본 요소이므로 모두 토큰이다.

```jsx
// 변수 선언문
var x;

// 표현식 문(할당문)
x = 5;

// 함수 선언문
function foo () {}

// 조건문
if (x > 1) { console.log(x); }
```

> 세미콜론과 세미콜론 자동 삽입 기능

세미콜론은 생략 가능하다.

<aside>
💡 자바스크립트 엔진이 소스코드를 해석할 때 문의 끝이라고 예측되는 지점에 세미콜론을 자동으로 붙여주는 세미콜론 자동 삽입 기능이 암묵적으로 수행되기 때문이다.
</aside>

> 표현식인 문과 표현식이 아닌 문

<aside>
💡 표현식인 문과 표현식이 아닌 문을 구별하는 가장 간단하고 명료한 방법은 변수에 할당해 보는 것이다.
</aside>

표현식은 문의 일부일 수도 있고, 그 자체로 문의 될수도 있다.

```jsx
// 변수 선언문은 값으로 평가될 수 없으므로 표현식이 아니다.
var x;

// 1, 2, 1 + 2, x = 1 + 2는 모두 표현식이다.
// x = 1 + 2는 표현식이면서 완전한 문이기도 하다.
x = 1 + 2;
```

`x = 100` 할당문은 자체가 표현식이다. 숫자 값 100으로 평가된다.

```jsx
// 변수 선언문은 표현식이 아닌 문이다.
var x;

// 할당문은 그 자체가 표현식이지만 완전한 문이기도 하다. 즉, 할당문은 표현식인 문이다.
x = 100;
```