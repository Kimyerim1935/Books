목차
 6.1 숫자 타입
 6.7 심벌 타입
 6.8 객체 타입
 6.9 데이터 타입의 필요성
 6.10 동적 타이핑
✨ 데이터 할당
✨ 기본형 데이터와 참조형 데이터

자바스크립트의 모든 값은 데이터 타입을 갖는다. 자바스크립트는 7개의 데이터 타입을 제공하며, 7개 데이터 타입은 원시타입과 객체타입으로 분류할 수 있다.

- 원시 타입
    - 숫자(Number) 타입
    - 문자열(String) 타입
    - 불리언(Boolean) 타입
    - undefined 타입
    - null 타입
    - 심벌(Symbol) 타입
- 객체 타입
    - 객체, 함수, 배열 등

### 6.1 숫자 타입

자바스크립트는 모든 수를 실수로 처리하며, 정수만 표현하기 위한 데이터 타입이 별도로 존재하지 않는다.

숫자 타입은 추가적으로 Infinity(양의 무한대), -Infinity(음의 무한대), NaN(산술 연산 불가) 이런 값들도 표현할 수 있다.

### 6.7 심벌 타입

심벌은 변경 불가능한 원시 타입의 값이다. 심벌 값은 다른 값과 중복 되지 않는 유일무이한 값이다.

주로 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용한다.

### 6.8 객체 타입

자바스크립트는 객체 기반의 언어이며, 자바스크립트를 이루고 있는 거의 모든 것은 객체이다.

### 6.9 데이터 타입의 필요성

**6.9.1 데이터 타입에 의한 메모리 공간의 확보와 참조**

자바스크립트 엔진은 데이터 타입(값의 종류)에 따라 정해진 크기의 메모리 공간을 확보한다.

변수에 할당되는 값의 데이터 타입에 따라 확보해야 할 메모리 공간의 크기가 결정된다.

**6.9.2 데이터 타입에 의한 값의 해석**

모든 값은 데이터 타입을 가지며 메모리의 2진수(비트의 나열)로 저자왼다. 메모리에 저장된 값은 데이터 타입에 따라 다르게 해석될 수 있다.

자바스크립트에서 데이터 타입이 필요한 이유는 다음과 같다.

- 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해
- 값을 참조할 때 한 번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해
- 메모리에서 읽어 들인 2진수를 어떻게 해석할 지 결정하기 위해

### 6.10 동적 타이핑

**6.10.1 동적 타입 언어와 정적 타입 언어**

typeof 연산자로 변수를 연산하면 변수의 할당된 값의 데이터 타입을 반환한다.

자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정된다. 그리고 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다. 자바스크립트를 정적 타입언어와 구별하기 위해 동적 타입 언어라고 한다.

**6.10.2 동적 타입 언어와 변수**

자바스크립트는 개발자의 의도와 상관 없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동으로 변환되기도 한다. 따라서 변수를 사용할 때 주의할 사항은 다음과 같다.

- 변수는 꼭 필요한 경우에 한해 제한적으로 사용
    - 재할당에 의해 언제든지 변경될 수 있기 때문에 변수의 개수가 많을 수록 오류가 발생할 확률이 높아진다.
- 변수의 유효 범위(스코프)는 최대한 좁게 만들기
    - 스코프가 넓을수록 변수로 인해 오류가 발생할 확률이 높아진다.
- 전역 변수는 최대한 사용하지 않기
    - 어디서든지 참조/변경 가능한 전역 변수는 의도치 않게 값이 변경될 가능성이 높고, 다른 코드에 영향을 줄 가능성이 있다.
- 변수보다는 상수를 사용하여 값의 변경 억제하기
- 변수 이름은 목적이나 의미를 파악할 수 있도록 짓기

가독성이 좋게 작성해야한다.

### ✨ 기본형 데이터와 참조형 데이터

**1. 불변값**

변수와 상수를 구분짓는 변경 가능성의 대상은 **변수 영역 메모리**이다. 한 번 데이터 할당이 이뤄진 변수 공간에 다른 데이터를 재할당 할 수 있는지 여부가 관건이다.

불변성 여부를 구분할 때의 변경 가능성의 대상은 **데이터 영역 메모리**이다.

```jsx
var a = 'abc';
a = a + 'def';

var b = 5;
var c = 5;
b = 7;
```

변수 a에 문자열 ‘abc’를 할당했다가 ‘def’를 추가하면 새로운 문자열 ‘abcdef’를 만든 후 그 주소를 변수 a에 저장한다.

변수 b에 5를 할당할 때, 컴퓨터는 데이터 영역에서 5를 찾고, 없으면 데이터 공간을 하나 만들어서 저장한다. 그런 다음, 그 주소를 b에 저장한다.

c에다가 5를 할당할 때, 컴퓨터는 데이터 영역에서 5를 찾는다. b에 5를 할당할 때 이미 5를 저장해뒀으니, c에도 같은 주소를 할당한다.

변수 b의 값을 7로 변경하려고 할 때, 기존에 저장된 5를 7로 변경하는 것이 아니라 기존에 저장했던 7을 찾아서 있으면 재활용하고, 없으면 데이터 공간을 새로 만들어서 저장한 다음 그 주소를 b에 할당한다.

문자열 값도 한 번 만든 값을 바꿀 수 없고, 숫자 값도 다른 값으로 변경할 수 없다. 변경은 새로 만드는 동작을 통해서만 이뤄진다. 이것이 불변값의 성질이다. 한 번 만들어진 값은 가비지 컬렉팅으르 당하지 않는 한 영원히 변하지 않는다.

**2. 가변값**

참조형 데이터를 변수에 할당하는 과정은 다음과 같다.

```jsx
var obj1 = {
	a: 1,
	b: 'bbb'
};
```

| 주소(변수 영역) | 1001 | 1002 | 1003 | 1004 |
| --- | --- | --- | --- | --- |
| 데이터 |  | 이름: obj1
값:@5001 |  |  |
| 주소(데이터 영역) | 5001 | 5002 | 5003 | 5004 |
| 데이터 | @7103 ~ ? |  | 1 | ‘bbb’ |

| 주소
(객체 @5001의 변수 영역) | 7103 | 7104 | 7105 | 7106 |
| --- | --- | --- | --- | --- |
| 데이터 | 이름: a
값: @5003 | 이름: b
값: @5004 |  |  |

1️⃣ 변수 영역의 빈공간(@1002)를 확보하고, 그 주소의 이름을 obj1로 지정한다.

2️⃣ 임의의 데이터 저장 공간(@5001)에 데이터를 저장하려고 보니, 여러 개의 프로퍼티로 이뤄진 데이터 그룹이다. 이 그룹 내부의 프로퍼티들을 저장하기 위해 별도의 변수 영역을 마련하고, 그 영역의 주소를 @5001에 저장한다.

3️⃣ @7103과 @7104에 각각 a와 b라는 프로퍼티 이름을 지정한다.

4️⃣ 데이터 영역에서 숫자 1을 검색한 다음, 검색 결과가 없으므로 임의로 @5003에 저장하고, 이 주소를 @7103에 저장한다. 문자열 ‘bbb’도 임의로 @5004에 저장하고, 이 주소를 @7104에 저장한다.

기본형 데이터와의 차이점은 ‘객체의 변수(프로퍼티 영역)’이 별도로 존재한다는 점이다.

객체가 별도로 할애한 영역은 변수 영역이고 데이터 영역은 기존의 메모리 공간을 그대로 사용하고 있다. 데이터 영역에 저장된 값은 모두 불변 값이지만 변수에는 다른 값의 할당이 가능하다. 그렇기 때문에 참조형 데이터는 불변하지 않다.

```jsx
var obj1 = {
	a: 1,
	b: 'bbb'
};

obj1.a = 2;
```

obj1.a에 2를 할당하려고 할 때, 데이터 영역에서 숫자 2를 검색하고 검색 결과가 없으므로 빈 공간인 @5005에 저장하고, 이 주소를 @7103에 저장한다. 이 때, 변수 obj1의 주소는 @5001로 그대로이다.

중첩 객체의 데이터 할당은 이렇게 이뤄진다.

```jsx
var obj = {
	x: 3,
	arr: [3, 4, 5];
};
```

| 주소(변수 영역) | 1001 | 1002 | 1003 | 1004 | 1005 |
| --- | --- | --- | --- | --- | --- |
| 데이터 |  | 이름: obj
값: @5001 |  |  |  |
| 주소(데이터 영역) | 5001 | 5002 | 5003 | 5004 | 5005 |
| 데이터 | @7103 ~ ? | 3 | @8104 ~ ? | 4 | 5 |

| 주소
(객체 @5001의 변수 영역) | 7103 | 7104 |  |
| --- | --- | --- | --- |
| 데이터 | 이름: x
값: @5002 | 이름: arr
값: @5003 |  |

| 주소
(배열 @5003의 변수 영역) | 8104 | 8105 | 8106 |  |
| --- | --- | --- | --- | --- |
| 데이터 | 이름: 0
값: @5002 | 이름: 1
값: @5004 | 이름: 2
값: @5005 |  |

1️⃣ 변수 영역의 빈공간(@1002)를 확보하고, 그 주소의 이름을 obj로 지정한다.

2️⃣ 임의의 데이터 저장 공간(@5001)에 데이터를 저장하려고 보니, 여러 개의 프로퍼티로 이뤄진 데이터 그룹이다. 이 그룹 내부의 프로퍼티들을 저장하기 위해 별도의 변수 영역을 마련하고, 그 영역의 주소를 @5001에 저장한다.

3️⃣ @7103에 x를, @7104에 arr을 지정한다.

4️⃣ 데이터 영역에서 숫자 3을 검색한 다음, 검색 결과가 없으므로 임의로 @5002에 저장하고, 이 주소를 @7103에 저장한다.

5️⃣ @7104에 저장할 값은 배열로서 데이터 그룹이다. 그룹 내부의 프로퍼티들을 저장하기 위해 별도의 변수 영역을 마련하고(@8104~?), 그 영역의 주소 정보를 @5003에 저장한다.

6️⃣ 배열의 요소가 총 3개 이므로 각각 변수 공간을 확보하고, 인덱스를 부여한다.

7️⃣ 데이터 영역에서 3을 검색하여 그 주소를 @8104에 저장한다.

8️⃣ 데이터 영역에 숫자 4가 없으므로 @5004에 저장하고 그 주소를 @8105에 저장한다.

9️⃣ 데이터 영역에 숫자 5가 없으므로 @5005에 저장하고 그 주소를 @8106에 저장한다.

`obj.arr = ‘str’;` 라고 재할당을 하게 되면,

| 주소(변수 영역) | 1001 | 1002 | 1003 | 1004 | 1005 | 1006 |
| --- | --- | --- | --- | --- | --- | --- |
| 데이터 |  | 이름: obj
값: @5001 |  |  |  |  |
| 주소(데이터 영역) | 5001 | 5002 | 5003 | 5004 | 5005 | 5006 |
| 데이터 | @7103 ~ ? | 3 | @8104 ~ ? | 4 | 5 | ‘str’ |

| 주소
(객체 @5001의 변수 영역) | 7103 | 7104 |  |
| --- | --- | --- | --- |
| 데이터 | 이름: x
값: @5002 | 이름: arr
값: @5006 |  |

| 주소
(배열 @5003의 변수 영역) | 8104 | 8105 | 8106 |  |
| --- | --- | --- | --- | --- |
| 데이터 | 이름: 0
값: @5002 | 이름: 1
값: @5004 | 이름: 2
값: @5005 |  |

**해당 표시**가 된 항목들은 참조 카운트가 0이기 때문에 가비지 컬렉터의 수거 대상이 된다. 가비지 컬렉터는 런타임 환경에 따라 특정 시점이나 메모리 사용량이 포화 상태에 임박할 때마다 자동으로 수거 대상들을 수거한다. 수거된 메모리는 다시 빈 공간이 된다.

**3. 변수 복사 비교**

```jsx
var a = 10;
var b = a;

var obj1 = {
	c: 10,
	d: 'ddd'
};
var obj2 = obj1;
```

| 주소(변수 영역) | 1001 | 1002 | 1003 | 1004 | 1005 | 1006 |
| --- | --- | --- | --- | --- | --- | --- |
| 데이터 | 이름: a
값: @5001 | 이름: b
값: @5001 | 이름: obj1
값: @5002 | 이름: obj2
값: @5002 |  |  |
| 주소(데이터 영역) | 5001 | 5002 | 5003 | 5004 |  |  |
| 데이터 | 10 | @7103 ~ ? | 'ddd’ |  |  |  |

| 주소
(객체 @5002의 변수 영역) | 7103 | 7104 |  |
| --- | --- | --- | --- |
| 데이터 | 이름: c
값: @5001 | 이름: d
값: @5003 |  |

기본형 데이터의 복사는 다음과 같이 이루어진다.

1️⃣변수 영역의 빈 공간(@1002)를 확보하고 식별자(변수명)를 b로 지정한다.

2️⃣ 식별자 a를 검색한 다음, 그 값을 찾아와서 @1002의 값에 대입한다(@500**1)**

참조형 데이터의 복사는 다음과 같이 이루어진다.

1️⃣ 변수 영역의 빈 공간(@1004)를 확보하고 식별자(변수명)를 obj2로 지정한다.

2️⃣ 식별자 obj1를 검색한 다음, 그 값을 찾아와서 @1004의 값에 대입한다(@5002)

변수를 복사하는 과정은 기본형 데이터와 참조형 데이터 모두 같은 주소를 바라보게 된다는 점에서 동일하지만, 데이터 할당 과정에서 참조형 데이터의 경우 한 단계를 더 거치기 때문에 변수 복사 이후의 동작에도 큰 차이가 발생한다.

```jsx
var a = 10;
var b = a;

var obj1 = {
	c: 10,
	d: 'ddd'
};
var obj2 = obj1;

b = 15;
obj2.c = 20;
```

| 주소(변수 영역) | 1001 | 1002 | 1003 | 1004 | 1005 | 1006 |
| --- | --- | --- | --- | --- | --- | --- |
| 데이터 | 이름: a
값: @5001 | 이름: b
값: @5004 | 이름: obj1
값: @5002 | 이름: obj2
값: @5002 |  |  |
| 주소(데이터 영역) | 5001 | 5002 | 5003 | 5004 | 5005 |  |
| 데이터 | 10 | @7103 ~ ? | 'ddd’ | 15 | 20 |  |

| 주소
(객체 @5002의 변수 영역) | 7103 | 7104 |  |
| --- | --- | --- | --- |
| 데이터 | 이름: c
값: @5005 | 이름: d
값: @5003 |  |

기본형 데이터를 복사한 변수 b의 값을 바꿨더니 @1002의 값이 달라진 반면, 참조형 데이터를 복사한 변수 obj2의 프로퍼티 값을 바꿨더니 @1004의 값은 달라지지 않았다.

대부분의 자바스크립트 책에서 기본형은 값을 복사하고, 참조형은 주솟값을 복사한다고 설명하지만, 사실, 어떤 데이터 타입이든 변수에 할당하기 위해서는 주솟값을 복사해야하기 때문에 엄밀히 따지면 모든 자바스크립트의 데이터타입은 참조형 데이터일 수 밖에 없다.

```jsx
var a = 10;
var b = a;

var obj1 = {
	c: 10,
	d: 'ddd'
};
var obj2 = obj1;

b = 15;
obj2 = {
	c: 20,
	d: 'ddd'
}
```

| 주소(변수 영역) | 1001 | 1002 | 1003 | 1004 | 1005 | 1006 |
| --- | --- | --- | --- | --- | --- | --- |
| 데이터 | 이름: a
값: @5001 | 이름: b
값: @5004 | 이름: obj1
값: @5002 | 이름: obj2
값: @5006 |  |  |
| 주소(데이터 영역) | 5001 | 5002 | 5003 | 5004 | 5005 | 5006 |
| 데이터 | 10 | @7103 ~ ? | 'ddd’ | 15 | 20 | @8024~? |

| 주소
(객체 @5002의 변수 영역) | 7103 | 7104 |
| --- | --- | --- |
| 데이터 | 이름: c
값: @5001 | 이름: d
값: @5003 |

| 주소
(객체 @5002의 변수 영역) | 8204 | 8205 |
| --- | --- | --- |
| 데이터 | 이름: c
값: @5005 | 이름: d
값: @5003 |

변수 b와 마찬가지로 obj2에도 새로운 객체를 할당함으로써 값을 직접 변경했다.

완전 새로운 객체를 할당했기때문에 값들의 주소가 전부 달라졌음을 확인할 수 있다.

✨ 참조형 데이터가 가변값이라고 설명할 때의 가변은 참조형 데이터 자체를 변경할 경우가 아니라, 내부의 프로퍼티를 변경할 때만 성립한다.